Парсер pdoTools представляет из себя отдельный класс, который прописывается в системных настройках MODX и перехватывает обработку тегов на странице.

В старых версиях компонента, включение парсера нужно было подтверждать при установке, но с версии 2.1.1-pl он включается по умолчанию. Если, по каким-то причинам, вас это не устраивает - удалите системные настройки
* **parser_class** - имя класса парсера
* **parser_class_path** - путь к классу парсера

По умолчанию в MODX нет этих настроек, они нужны только для подключения стороннего парсера, как в нашем случае.

## Принцип работы
pdoParser может быть использован в двух случаях:
* при рендере чанка сниппетом - это происходит всегда и во всех сниппетах, использующих pdoTools, независимо от системных настроек.
* при рендере страницы - только если парсер включен в настройках системы.

## Обработка чанка
В классе pdoTools для этого есть 2 метода, очень похожих на таковые в классе modX:
* **getChunk** - полная обработка чанка, может задействовать родной парсер MODX
* **parseChunk** - только замена плейсхолдеров на значения, modParser не вызывается
 
Основной особенностью работы этих методов является то, что для загрузки чанка используется protected метод **_loadChunk**, который может не только загружать чанк из базы данных, но и превращает в него произвольные строки.

### Варианты чанков
Итак, оба метода pdoTools поддерживают следующие виды имён чанков:
#### @INLINE или @CODE
Один из самых популярных вариантов - указание тела чанка прямо на странице. Например:
```
[[!pdoResources?
    &parents=`0`
    &tpl=`@INLINE <p>{{+id}} - {{+pagetitle}}</p>`
]]
```
В таком указании есть особенность, о которой многие люди не задумываются - все плейсхолдеры внутри чанка будут обработаны парсером **до** вызова сниппета.

То есть, если вызвать сниппет на странице вот так:
```
[[!pdoResources?
    &parents=`0`
    &tpl=`@INLINE <p>[[+id]] - [[+pagetitle]]</p>`
]]
```
и в памяти системы при этом выставлены плейсхолдеры `[[+id]]` или `[[+pagetitle]]`, то в сниппет придёт уже обработанный чанк и вы получите на странице одинаковые строки, типа:
```
15 - тест
15 - тест
15 - тест
```
Просто одинаковые значения, которые выставил какой-то другой сниппет раньше. Именно поэтому в примере у нас такие необычные плейсхолдеры - `{{+}}` вместо `[[+]]`. Системный парсер их не трогает, а pdoTools заменяет их на нормальные во время работы.

Вы можете использовать фигурные скобочки в качестве обрамления плейсхолдеров во всех чанках pdoTools - он сам превратит их в `[[+]]` при загрузке.

По этой же причине у вас никогда не будут работать вызовы сниппетов и фильтров в INLINE чанках. **Вот так работать не будет**:
```
[[!pdoResources?
    &parents=`0`
    &tpl=`@INLINE <p>[[+id]] - [[+pagetitle:default=`название страницы`]]</p>`
]]
```
А вот так - без проблем
```
[[!pdoResources?
    &parents=`0`
    &tpl=`@INLINE <p>{{+id}} - {{+pagetitle:default=`название страницы`}}</p>`
]]
```

Помните об этом нюансе при использовании INLINE чанков.

#### @FILE
Многие люди обвиняют MODX в том, что он не умеет хранить чанки в файлах и вынуждает лишний раз работать с базой данных. Это и неудобно для системы контроля версий, и медленнее.

С версии 2.2 MODX [предлагает использовать для этих целей статичные элементы][3], но по ряду причин, этот способ всё равно может быть менее удобен, чем прямая работа с файлами.

pdoTools открывает такую возможность при указании @FILE:
```
[[!pdoResources?
    &parents=`0`
    &tpl=`@FILE resources/mychank.tpl`
]]
```
В целях безопасности, использовать можно только файлы с расширеним **html** и **tpl**, и только из определённой, заранее заданной директории. По умолчанию это: `/assets/elements/chunks/`.

Вы можете указать свою собственную директорию для файлов через параметр `&tplPath`:
```
[[!pdoResources?
    &parents=`0`
    &tpl=`@FILE resources/mychunk.tpl`
    &tplPath=`/core/elements`
]]
```
Файл будет загружен из файла `/core/elements/resources/mychunk.tpl` от корня сайта.

#### @TEMPLATE
Этот тип чанка позволяет использовать шаблоны системы (т.е. объекты modTemplate) для оформления вывода.
```
[[!pdoResources?
    &parents=`0`
    &tpl=`@TEMPLATE Base Template`
]]
```
Если указан пустой шаблон и в выбранных записях есть поле `template` с id или именем шаблона, то запись будет обёрнута в этот шаблон:
```
[[!pdoResources?
    &parents=`0`
    &tpl=`@TEMPLATE`
]]
```
Это такой аналог сниппета [renderResources][4].

При выводе шаблона можно указывать и набор параметров (как у сниппетов):
```
[[!pdoResources?
    &parents=`0`
    &tpl=`@TEMPLATE Base Template@MyPropertySet`
]]
```
Тогда значения из этого набора будут вставлены в шаблон.

#### Обычные чанки
Это режим по умолчанию, который загружает чанк из базы данных:
```
[[!pdoResources?
    &parents=`0`
    &tpl=`MyChunk`
]]
```
Точно так же поддерживаются и наборы параметров:
```
[[!pdoResources?
    &parents=`0`
    &tpl=`MyChunk@MyPropertySet`
]]
```

Эти способы загрузки чанков работают **во всех родных сниппетах pdoTools** и во всех других, которые используют методы pdoTools `getChunk` и `parseChunk`.

### Метод getChunk
Объявление этого метода выглядит так:
```
getChunk(string $chunkName, array $properties, bool $fastMode = false)
```
Метод загружает указанный чанк (следуя указанию @BINDING, если есть) и полностью обратывает его, заменяя все плейсхолдеры на переданные значения (параметр $properties).

Третий параметр `fastMode` вырезает все оставшиеся необработанные плейсхолдеры, чтобы не было лишних тегов на странице. Если этого не сделать, то парсер будет пытаться рекурсивно разобрать эти теги (до 10 итераций по умолчанию), что может привести к замедлению работы.

Рекурсивный парсер - это одно из достоинств MODX и специально оставленные теги очень часто встречаются в логике работы сниппетов системы. Поэтому `fastMode` отключен по умолчанию и использовать его нужно, только если вы уверены в том, что делаете.

Парсер pdoTools не будет вызывать системный парсер, если смог самостоятельно разобрать все плейсхолдеры. Если же в чанке остались какие-то вызовы фильтров или сниппетов, то работа передаётся в modParser, что требует дополнительное время на обработку.

### Метод parseChunk
А этот метод объявлен вот так:
```
parseChunk(string $name, array $properties, string $prefix = '[[+', string $suffix = ']]')
```
Он также создаёт чанк из указанного имени, разбирая @BINDING, если есть, а потом просто заменяет плейсхолдеры на значения, без особых обработок.

Это самый простой и быстрый способ оформления данных в чанки.

## Обработка страницы
Если pdoParser включен в настройках, то он вызывается и для обработки всей страницы при выводе её пользователю.

При использовании этого парсера все чанки и дополнения MODX обрабатываются немного быстрее. Всего лишь "немного" потому, что он не берёт на себя условия и фильтры, обрабатывая только простенькие теги, типа `[[+id]]` и `[[~15]]`. Однако, он это делает быстрее modParser, потому что не создаёт лишних объектов.

Помимо возможной прибавки скорости, вы получаете еще и новые возможности по удобному выводу данных из разных ресурсов.

### Теги fastField
В конце 2012 года общественности [был представлен][5] небольшой плагин с добавлением новых тегов парсеру MODX, который затем вырос в [компонент fastField][1].

Он добавляет в систему обработку дополнительных плейсхолдеров, типа `[[#15.pagetitle]]`. [С разрешения автора][2], этот функционал уже включен в pdoParser, и даже немного расширен.

Все теги fastField начинаются с `#` и дальше содержат или **id нужного ресурса**, или название глобального массива.

Вывод обычных полей ресурсов:
```
[[#15.pagetitle]]
[[#20.content]]
```

ТВ параметры ресурсов:
```
[[#15.date]]
[[#20.some_tv]]
```

Поля товаров miniShop2:
```
[[#21.price]]
[[#22.article]]
```

Массивы ресурсов и товаров:
```
[[#12.properties.somefield]]
[[#15.size.1]]
```

Суперглобальные массивы:
```
[[#POST.key]]
[[#SESSION.another_key]]
[[#GET.key3]]
[[#REQUEST.key]]
[[#SERVER.key]]
[[#FILES.key]]
[[#COOKIE.some_key]]
```

Можно указывать любые поля в массивах:
```
[[#15.properties.key1.key2]]
```

Если вы не знаете, какие значения находятся внутри массива - просто укажите его и он будет распечатан полностью:
```
[[#GET]]
[[#15.colors]]
[[#12.properties]]
```

Теги fastField можно сочетать с тегами MODX:
```
[[#[[++site_start]].pagetitle]]

[[#[[++site_start]]]]
```

### Шаблонизатор Fenom
Поддержка шаблонизатора Fenom [появилась в pdoTools с версии 2.0][6], после чего он стал требовать PHP 5.3+.

Он работает гораздо быстрее, чем родной modParser, и если вы перепишите свой чанк так, что в нём не будет ни одного тега MODX, то modParser и вовсе не будет запускаться. При этом, конечно, одновременная работа и старых тегов, и новых в одном чанке **допускается**.

На обработку шаблонизатором влияют следующие системные настройки:
* **pdotools_fenom_default** - включает обработку через Fenom чанков pdoTools. Включено по умолчанию.
* **pdotools_fenom_parser** - включает обработку шаблонизатором всех страниц сайта. То есть, не только чанков, но и шаблонов.
* **pdotools_fenom_php** - включает поддержку PHP функций в шаблонизаторе. Очень опасная функция, так как любой менеджер получит доступ к PHP прямо из чанка.
* **pdotools_fenom_modx** - добавляет системные переменные `{$modx}` и `{$pdoTools}` в шаблоны Fenom. Тоже очень опасно - любой менеджер может управлять объектами MODX  из чанков.
* **pdotools_fenom_options** - JSON строка с массивом настроек согласно [официальной документации][7]. Например: `{"auto_escape":true,"force_include":true}`
* **pdotools_fenom_cache** - кэширование скопмилированных шаблонов. Имеет смысл только для сложных чанков на рабочих сайтах, по умолчанию отключено.

Итак, по умолчанию Fenom включен для работы только в чанках, которые проходят через pdoTools. Это вполне безопасно и менеджеры системы не получают никаких дополнительных возможностей, кроме более удобного синтаксиса и высокой скорости работы.

Включение **pdotools_fenom_parser** позволяет использовать синтаксис Fenom прямо в контенте документов и шаблонах страниц, но есть один нюанс - шаблонизатор может неверно реагировать на фигурные скобочки, которые в MODX очень любят. 

В таких случаях автор рекомендует использовать тег {[ignore][8]}.

Если вы планируете включить Fenom глобально для всего сайта, вам нужно проверить, на всех ли страницах он нормально работает.

#### Синтаксис
Для начала советую прочитать [официальную документацию][9], а дальше мы рассмотрим синтаксис применительно к MODX.

Все переменные от сниппетов передаются в чанк как есть, поэтому переписывать старые чанки на новый синтаксис - сплошное удовольствие.


|	MODX	| Fenom
|-----------------------|-------------
| [[+id]]				| {$id}
| [[+id:default=`test`]] | {$id ?: 'test'}
| [[+id:is=``:then=`test`:else=`[[+pagetitle]]`]] | {$id == '' ? 'test' : $pagetitle}

Для использования более сложных сущностей, в pdoParser предусмотрена служебная переменная **{$_modx}**, которая даёт безопасный доступ к некоторым переменным и методам системы.

|	MODX	| Fenom
|-----------------------|-------------
| [[*id]]				| {$_modx->resource.id}
| [[*tv_param]]			| {$_modx->resource.tv_param}
| [[%lexicon]]			| {$_modx->lexicon('lexicon')}
| [[~15]]				| {$_modx->makeUrl(15)}
| [[~[[*id]]]]			| {$_modx->makeUrl($_modx->resource.id)}
| [[++system_setting]]	| {$_modx->config.system_setting}

Помимо этого вам доступны переменные:
**{$_modx->config}** - системные настройки
```
{$_modx->config.site_name}
{$_modx->config.emailsender}
{$_modx->config['site_url']}
{$_modx->config['any_system_setting']}
```
**{$_modx->user}** - массив текущего пользователя. Если он авторизован, то добавляются и данные из профиля:
```
{if $_modx->user.id > 0}
	Привет, {$_modx->user.fullname}!
{else}
	Вам нужно авторизоваться.
{/if}
```

**{$_modx->context}** - массив с текущим контекстом
```
Вы находитесь в контексте {$_modx->context.key}
```
**{$_modx->resource}** - массив с текущим ресурсом, это вы уже видели в примерах выше
```
{$_modx->resource.id}
{$_modx->resource.pagetitle}
{$_modx->makeUrl($_modx->resource.id)}
```
**{$_modx->lexicon}** - объект (не массив!) **modLexicon**, который можно использовать для загрузки произвольных словарей:
```
{$_modx->lexicon->load('ms2gallery:default')}
Проверка словарей ms2Gallery: {$_modx->lexicon('ms2gallery_err_gallery_exists')}
```
За вывод записей отвечает отдельная функция `{$_modx->lexicon()}`.

#### Плейсхолдеры с точкой
Fenom использует точку для доступа к значению массива, а MODX обычно выствляет так плейсхолдеры из массивов. Соотвественно, для тегов [[+tag.sub_tag]] аналогов в Fenom не предусмотрено.

Поэтому для подобных плейсхолдеров вам необходимо использовать вторую служебную  переменную - **{$_pls}**:
```
{$_pls['tag.subtag']}
```

#### Вывод сниппетов и чанков
Переменная `{$_modx}` на самом деле представляет собой простой и безопасный [класс microMODX][10]

Поэтому сниппеты и чанки вызываются так:
```
{$_modx->runSnippet('!pdoPage@PropertySet', [
	'parents' => 0,
	'showLog' => 1,
	'element' => 'psoResources',
	'where' => ['isfolder' => 1],
	'showLog' => 1,
])}
{$_modx->getPlaceholder('page.total')}
{$_modx->getPlaceholder('page.nav')}
```
Как видите, синтаксис практически полностью повторяет PHP, что открывает новые возможности. Например, можно указывать массивы, вместо JSON строк.

По умолчанию все сниппеты вызываются кэшированными, но вы можете добавить `!` перед именем - как в тегах MODX.

Если для вызова сниппета используется родной метод MODX, то для вывода чанков запускается pdoTools, и вы можете использовать все его возможности:
```
{$_modx->getChunk('MyChunk@PropertySet')}

{$_modx->parseChunk('MyChunk', [
	'pl1' => 'placeholder1',
	'pl2' => 'placeholder2',
])}

{$_modx->getChunk('@TEMPLATE Base Template')}

{$_modx->getChunk('@INLINE
	Имя сайта: {$_modx->config.site_name}
')}

{$_modx->getChunk(
    '@INLINE Передача перемнной в чанк: {$var}',
    ['var' => 'Тест']
)}

{$_modx->getChunk('
    @INLINE Передача переменной в вызов сниппета:
    {$_modx->runSnippet("pdoResources", [
	    "parents" => $parents
    ])}
    Всего результатов: {$_modx->getPlaceholder("total")}
    ',
    ['parents' => 0]
)}
```
Примеры выше немного безумные, но вполне себе работают.

#### Управление кэшированием
В объекте **{$_modx}** доступен сервиc modX::cacheManager, который позволяет вам устанавливать произвольное время кэширование вызываемых сниппетов:
```
{if !$snippet = $_modx->cacheManager->get('cache_key')}
    {set $snippet = $_modx->runSnippet('!pdoResources', [
        'parents' => 0,
        'tpl' => '@INLINE {$id} - {$pagetitle}',
        'showLog' => 1,
    ])}
    {set $null = $_modx->cacheManager->set('cache_key', $snippet, 1800)}
{/if}

{$snippet}
```
Посмотреть этот кэш можно в `/core/cache/default/`, в примере он сохраняется на 30 минут.

`set $null = ...` нужен, чтобы `cacheManager->set` не вывел 1 (т.е. true) на страницу.

А еще вы можете запускать системные процессоры (если прав хватит):
```
{$_modx->runProcessor('resource/update', [
	'id' => 10,
	'alias' => 'test',
	'context_key' => 'web',
])}
```

#### Проверка авторизации
Так как объекта с пользователем в `{$_modx}` нет, методы проверки авторизации и прав доступа вынесены непосредственно в класс:
```
{$_modx->isAuthenticated()}
{$_modx->hsSessionContext('web')}
{$_modx->hasPermission('load')}
```

#### Остальные методы
Эти методы должны быть знакомы всем разработчикам MODX, поэтому просто покажу их на примерах:
```
{$_modx->regClientCss('/assets/css/style.css')}
{$_modx->regClientScript('/assets/css/script.js')}

{$_modx->sendForward(10)}
{$_modx->sendRedirect('http://yandex.ru')}

{$_modx->setPlaceholder('key', 'value')}
{$_modx->getPlaceholder('key')}

{if $res = $_modx->findResource('url-to/doc/')}
	{$_modx->sendRedirect( $_modx->makeUrl($res) )}
{/if}
```

### Расширение шаблонов
Использование шаблонизатора Fenom позволяет включать одни чанки (шаблоны в другие) и даже расширять их.

Например, вы можете просто подгрузить содержимое чанка:
```
Обычный чанк {include 'имя чанка'}
Шаблон modTemplate {include 'template:имя шаблона'}
Чанк с набором параметров
{include 'chunk@propertySet'}
{include 'template:Name@propertySet'}
```
Подробнее про {[include][11]} читайте в официальной документации.

Гораздо более интересная функция - {[extends][12]} шаблонов, она требует включенной системной настройки **pdotools_fenom_parser**.

Пишем базовый шаблон "Fenom Base":
```
<!DOCTYPE html>
<html lang="en">
<head>
	{include 'head'}
</head>
<body>
	{block 'navbar'}
		{include 'navbar'}
	{/block}
	<div class="container">
		<div class="row">
			<div class="col-md-10">
				{block 'content'}
				    {$_modx->resource.content}
				{/block}
			</div>
			<div class="col-md-2">
				{block 'sidebar'}
					Sidebar
				{/block}
			</div>
		</div>
		{block 'footer'}
				{include 'footer'}
		{/block}
	</div>
</body>
</html>
```
Он включает обычные чанки (в которых, кстати, обычные плейсхолдеры MODX от компонента **Theme.Bootstrap**) и определяет несколько блоков `{block}`, которые можно расширить в другом шаблоне.

Теперь пишем "Fenom Extended":
```
{extends 'template:Fenom Base'}

{block 'content'}
    <h3>{$_modx->resource.pagetitle}</h3>
    <div class="jumbotron">
	    {parent}
    </div>
{/block}
```
Так вы можете написать один базовый шаблон и расширить его дочерними.

Точно также можно писать и расширять чанки, только обратите внимание, что для работы с modTemplate нужно указывать префикс **template:**, а для чанков нет — они работают по умолчанию во всех `{include}` и `{extends}`.

### Рабочий пример
Как пример скорости работы, вот код чанка вывода комментария на сайте **modx.pro**:
```
<div class="ticket-comment {$comment_new ? 'ticket-comment-new' : ''}" id="comment-{$id}" data-parent="{$parent}" data-newparent="{$new_parent}" data-id="{$id}">
	<div class="ticket-comment-body {$guest ? 'ticket-comment-guest' : ''} {$bad}">
		<div class="ticket-comment-header">
			<div class="ticket-comment-dot-wrapper"><div class="ticket-comment-dot"></div></div>
			<div class="user-avatar-wrapper">
				<img src="{$avatar}" class="ticket-avatar" alt="" />
			</div>
			<span class="ticket-comment-author">
				<a href="/users/{$createdby}/">{$fullname}</a>
			</span>
			<span class="ticket-comment-createdon">{$date_ago}</span>
			<span class="ticket-comment-link"><a href="{$url}#comment-{$id}">#</a></span>
			<span class="ticket-comment-star {$can_star ? 'active' : ''}">
				<i class="glyphicon glyphicon-star {$stared ? 'stared' : 'unstared'} star"></i>
			</span>
			{if $has_parent}
			<span class="ticket-comment-up">
				<a href="{$url}#comment-{$parent}" data-id="{$id}" data-parent="{$parent}">&uarr;</a>
			</span>
			{/if}
			<span class="ticket-comment-down"><a href="#" data-child="">&darr;</a></span>
			<span class="ticket-comment-rating {$can_vote ? 'active' : 'inactive'}">
				<span class="rating {$rating_positive ? 'positive' : ''}{$rating_negative ? 'negative' : ''}" title="Всего: {$rating_total}: ↑{$rating_plus} и ↓{$rating_minus}">{$rating}</span>
				<span class="vote plus {$voted_plus ? 'voted' : ''}" title="Нравится"><i class="glyphicon glyphicon-arrow-up"></i></span>
				<span class="vote minus {$voted_minus ? 'voted' : ''}" title="Не нравится"><i class="glyphicon glyphicon-arrow-down"></i></span>
			</span>
		</div>
		<div class="ticket-comment-text">
			{$text}
		</div>
	</div>
	<div class="comment-reply">
		<a href="#" class="reply"><i class="glyphicon glyphicon-pencil gray"></i> ответить</a>
		{if $comment_edit_link}
		<a href="#" class="edit">изменить</a>
		{/if}
		</div>
		<ol class="comments-list">{$children}</ol>
</div>
```


[Самая большая тема][15] с более чем **400** комментариев выводится без кэширования дополнением [Tickets][16] за **0.8 сек**. Счетчики можно посмотреть внизу страницы:
```
total time: 0.7668 s
query time: 0.0111 s
queries: 70
```


Рендер комментариев выдаёт вот такой лог:
```
0.0000930: pdoTools loaded
0.0015190: Conditions prepared
0.0001359: Query parameters prepared.
0.0000422: xPDO query object created
0.0001571: innerJoined TicketThread as Thread
0.0001528: leftJoined modUser as User
0.0001268: leftJoined modUserProfile as Profile
0.0001280: leftJoined TicketVote as Vote
0.0001261: leftJoined TicketStar as Star
0.0000050: Grouped by TicketComment.id
0.0000470: Added selection of TicketComment: SQL_CALC_FOUND_ROWS `id`, `thread`, `parent`, `text`, `name`, `email`, `ip`, `rating`, `rating_plus`, `rating_minus`, `createdon`, `createdby`, `editedon`, `editedby`, `published`, `deleted`, `deletedon`, `deletedby`, `properties`, `parent` as `new_parent`, `rating` as `rating_total`
0.0000150: Added selection of TicketThread: `resource`
0.0000129: Added selection of modUser: `username`
0.0000272: Added selection of modUserProfile: `internalKey`, `fullname`, `phone`, `mobilephone`, `blocked`, `blockeduntil`, `blockedafter`, `logincount`, `lastlogin`, `thislogin`, `failedlogincount`, `sessionid`, `dob`, `gender`, `address`, `country`, `city`, `state`, `zip`, `fax`, `photo`, `comment`, `website`, `extended`,`email` as `user_email`
0.0000150: Added selection of TicketVote: `value` as `vote`
0.0000789: Added selection of TicketStar: COUNT(`id`) as `star`
0.0001819: Added where condition: published=1
0.0000350: Sorted by TicketComment.id, ASC
0.0003719: SQL prepared "SELECT SQL_CALC_FOUND_ROWS `TicketComment`.`id`, `TicketComment`.`thread`, `TicketComment`.`parent`, `TicketComment`.`text`, `TicketComment`.`name`, `TicketComment`.`email`, `TicketComment`.`ip`, `TicketComment`.`rating`, `TicketComment`.`rating_plus`, `TicketComment`.`rating_minus`, `TicketComment`.`createdon`, `TicketComment`.`createdby`, `TicketComment`.`editedon`, `TicketComment`.`editedby`, `TicketComment`.`published`, `TicketComment`.`deleted`, `TicketComment`.`deletedon`, `TicketComment`.`deletedby`, `TicketComment`.`properties`, `parent` as `new_parent`, `rating` as `rating_total`, `Thread`.`resource`, `User`.`username`, `Profile`.`internalKey`, `Profile`.`fullname`, `Profile`.`phone`, `Profile`.`mobilephone`, `Profile`.`blocked`, `Profile`.`blockeduntil`, `Profile`.`blockedafter`, `Profile`.`logincount`, `Profile`.`lastlogin`, `Profile`.`thislogin`, `Profile`.`failedlogincount`, `Profile`.`sessionid`, `Profile`.`dob`, `Profile`.`gender`, `Profile`.`address`, `Profile`.`country`, `Profile`.`city`, `Profile`.`state`, `Profile`.`zip`, `Profile`.`fax`, `Profile`.`photo`, `Profile`.`comment`, `Profile`.`website`, `Profile`.`extended`, `Profile`.`email` as `user_email`, `Vote`.`value` as `vote`, COUNT(`Star`.`id`) as `star` FROM `modx_tickets_comments` AS `TicketComment` JOIN `modx_tickets_threads` `Thread` ON `Thread`.`id` = `TicketComment`.`thread` AND `Thread`.`name` = "resource-678" LEFT JOIN `modx_users` `User` ON `User`.`id` = `TicketComment`.`createdby` LEFT JOIN `modx_user_attributes` `Profile` ON `Profile`.`internalKey` = `TicketComment`.`createdby` LEFT JOIN `modx_tickets_votes` `Vote` ON `Vote`.`id` = `TicketComment`.`id` AND `Vote`.`class` = "TicketComment" AND `Vote`.`createdby` = 2 LEFT JOIN `modx_tickets_stars` `Star` ON `Star`.`id` = `TicketComment`.`id` AND `Star`.`class` = "TicketComment" AND `Star`.`createdby` = 2 WHERE `TicketComment`.`published` = 1 GROUP BY TicketComment.id ORDER BY TicketComment.id ASC "
0.0005820: SQL executed
0.0001822: Total rows: 446
0.0065300: Rows fetched
0.0185540: Returning raw data
0.4452200: Returning processed chunks
0.0029881: Loaded chunk "tpl.Tickets.comment.wrapper"
0.0048649: Compiled Fenom chunk with name "chunk/32"
0.0082240: Loaded chunk "tpl.Tickets.comment.form"
0.0017109: Compiled Fenom chunk with name "chunk/27"
0.4925370: Total time
30 670 848: Memory usage
```
Как видите, все 446 комментариев обрабатываются за 0.49 сек. Добавление всего одного тега с фильтром в чанк, чтобы для обработки начал запускаться modParser, увеличивает время до 0.72 сек, то есть - почти на треть.

## Заключение
Давайте подытожим возможности парсера pdoTools:

* Быстрая работа
* Поддержка тегов fastField
* Поддержка шаблонизатора Fenom
* * Наследование шаблонов
* * Расширение шаблонов
* * Безопасный доступ к продвинутым функциям MODX

На данный момент pdoTools скачан более 40 000 раз из [официального репозитория][13] и более 10 000 из [репозитория modstore.pro][14], что позволяет надеяться на широкое распространение новых технологий шаблонизации в MODX.

[1]: http://modx.com/extras/package/fastfield
[2]: https://github.com/argnist/fastField/issues/5
[3]: https://rtfm.modx.com/revolution/2.x/administering-your-site/upgrading-modx/upgrading-to-2.2.x#Upgradingto2.2.x-StaticElements
[4]: https://rtfm.modx.com/extras/revo/renderresources
[5]: http://habrahabr.ru/post/161843/
[6]: https://modx.pro/components/5598-pdotools-2-0-0-beta-c-templating-fenom/
[7]: https://github.com/fenom-template/fenom/blob/master/docs/ru/configuration.md
[8]: https://github.com/fenom-template/fenom/blob/master/docs/ru/tags/ignore.md
[9]: https://github.com/fenom-template/fenom/blob/master/docs/ru/syntax.md
[10]: https://github.com/bezumkin/pdoTools/blob/master/core/components/pdotools/model/pdotools/_micromodx.php
[11]: https://github.com/fenom-template/fenom/blob/master/docs/ru/tags/include.md
[12]: https://github.com/fenom-template/fenom/blob/master/docs/ru/tags/extends.md
[13]: http://modx.com/extras/package/pdotools
[14]: https://modstore.pro/pdotools
[15]: https://modx.pro/hosting/678-the-right-hosting-for-modx-revolution-2/
[16]: /ru/01_Компоненты/15_Tickets